# -*- coding: utf-8 -*-
"""ingles-2-cargas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RIk4t1bcSmOKoGmk-9MKQv_W_B7xiMpp
"""

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.dates import AutoDateLocator
from matplotlib.dates import HourLocator
from matplotlib.dates import MinuteLocator
from datetime import datetime, timedelta
from pandas import json_normalize
import seaborn as sns
import numpy as np

direccion = "/content/20-01-2025"  #carga ligera
#direccion = "/content/17-01-2025-1"  #carga pesada
nameColumn = ["IL", "IBAT", "IMPPT", "VT", "TIME"]
df = pd.read_csv(direccion+".txt",delimiter=',',names=nameColumn)



df['TIME'] = pd.to_datetime(df['TIME'])

#df["IBAT"] = - df['IBAT']
#df["IMPPT"] = - df['IMPPT']
df['IL'] = - df['IL']


df["PMPPT"] = df['IMPPT'] * df['VT']/1000
df["PL"] = df["IL"] * df ["VT"]/1000
df["PBAT"] = df["IBAT"] * df["VT"]/1000

# ---  Configuración Inicial ---
capacidad_ah = 6.6  # Capacidad de la batería en Ah
capacidad_coulomb = capacidad_ah * 3600  # Capacidad en Coulombs (Ah * 3600 segundos/hora)
#soc_inicial = 90  # carga pesada
soc_inicial = 95  #carga ligera

# ---  Inicializar lista para almacenar los valores de SOC ---
soc_values = [soc_inicial]

# ---  Iterar a través del DataFrame para calcular el SOC ---
for i in range(1, len(df)):
    tiempo_anterior = pd.to_datetime(df['TIME'].iloc[i-1]) # Convertir a datetime si no lo está
    tiempo_actual = pd.to_datetime(df['TIME'].iloc[i])     # Convertir a datetime si no lo está
    delta_tiempo_segundos = (tiempo_actual - tiempo_anterior).total_seconds() # Diferencia de tiempo en segundos
    corriente_ibat = df['IBAT'].iloc[i]/1000 # Corriente en Amperios

    # Calcular la carga que ha pasado en este intervalo de tiempo (en Coulombs)
    carga_pasada = corriente_ibat * delta_tiempo_segundos

    # Obtener el SOC anterior
    soc_anterior = soc_values[-1]

    # Calcular el nuevo SOC usando el método de Conteo de Coulomb
    # SOC(t) = SOC(t₀) - (∫ I(t) dt) / C_nominal * 100
    nuevo_soc = soc_anterior - (carga_pasada / capacidad_coulomb) * 100

    # Asegurar que el SOC se mantenga dentro del rango [0, 100]  (opcional, pero buena práctica)
    nuevo_soc = max(0, min(100, nuevo_soc))

    # Añadir el nuevo valor de SOC a la lista
    soc_values.append(nuevo_soc)

# --- Añadir la columna 'SOC' al DataFrame ---
df['SOC'] = soc_values

df['corrected_time'] = df['TIME']
df['corrected_time'] = pd.to_datetime(df['corrected_time'])
#offset = pd.Timestamp('2024-01-01 18:00:00') - df['corrected_time'].min() #carga pesada
offset = pd.Timestamp('2024-01-01 15:30:00') - df['corrected_time'].min()  #carga ligera
df['corrected_time2'] = df['corrected_time'] + offset

#df_f = df[(df['corrected_time2'] >= '2024-01-01 18:00:00') & (df['corrected_time2'] <= '2024-01-02 12:00:00')] #carga pesada
df_f = df[(df['corrected_time2'] >= '2024-01-01 18:00:00') & (df['corrected_time2'] <= '2024-01-02 18:00:00')] #carga ligera

plt.figure(figsize=(12, 5))
plt.plot(df_f['corrected_time2'], df_f['SOC'], label='State of chargue',color="orange")
plt.ylabel('SOC [%]', fontsize=18, labelpad=20)
plt.xlabel('Time [DD-HH-MM]', fontsize=18)

ax = plt.gca()
ax.xaxis.set_major_locator(HourLocator(interval=2))

plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%d-%H-%M'))
plt.xticks(rotation=45)
plt.tight_layout()
plt.tick_params(axis='both', which='major', labelsize=14)

plt.legend(fontsize=14, loc='lower center', bbox_to_anchor=(0.5, -0.45), ncol=3)

plt.grid(True)

plt.savefig('C1-SOC', format='eps', bbox_inches='tight')
plt.show()

plt.figure(figsize=(12, 5))
plt.plot(df_f['corrected_time2'], df_f['IMPPT']/1000, label='Source',color="blue")
plt.plot(df_f['corrected_time2'], df_f['IBAT']/1000, label='Batteries',color="orange")
plt.plot(df_f['corrected_time2'], df_f['IL']/1000, label='Load',color="green")
plt.ylabel('Current [A]', fontsize=18, labelpad=20)
plt.xlabel('Time [DD-HH-MM]', fontsize=18)

ax = plt.gca()
ax.xaxis.set_major_locator(HourLocator(interval=2))

plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%d-%H-%M'))
plt.xticks(rotation=45)
plt.tight_layout()
plt.tick_params(axis='both', which='major', labelsize=14)

plt.legend(fontsize=14, loc='lower center', bbox_to_anchor=(0.5, -0.45), ncol=3)

plt.grid(True)

plt.savefig('C1-Current', format='eps', bbox_inches='tight')
plt.show()

plt.figure(figsize=(12, 5))
plt.plot(df_f['corrected_time2'], df_f['PMPPT'], label='Source',color="blue")
plt.plot(df_f['corrected_time2'], df_f['PBAT'], label='Batteries', color="orange")
plt.plot(df_f['corrected_time2'], df_f['PL'], label='Load',color="green")
plt.ylabel('Power [W]', fontsize=18, labelpad=20)
plt.xlabel('Time [DD-HH-MM]', fontsize=18)

ax = plt.gca()
ax.xaxis.set_major_locator(HourLocator(interval=2))

plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%d-%H-%M'))
plt.xticks(rotation=45)
plt.tight_layout()
plt.tick_params(axis='both', which='major', labelsize=14)

plt.legend(fontsize=14, loc='lower center', bbox_to_anchor=(0.5, -0.45), ncol=3)

plt.grid(True)

plt.savefig('C1-Power', format='eps', bbox_inches='tight')
plt.show()