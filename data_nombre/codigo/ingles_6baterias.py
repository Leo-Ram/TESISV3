# -*- coding: utf-8 -*-
"""ingles-6baterias.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KSazocLTEvWLSDWaMYq52_OTw1cCoPb2
"""

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib.dates import AutoDateLocator
from matplotlib.dates import HourLocator
from matplotlib.dates import MinuteLocator
from datetime import datetime, timedelta
from pandas import json_normalize
import seaborn as sns
import numpy as np

direccion = "/content/balance"

nameColumn = ["B1", "B2", "B3", "B4", "B5", "B6", "I","T","VT","TIME"]
df = pd.read_csv(direccion+".txt",delimiter=',',names=nameColumn)

df['TIME'] = pd.to_datetime(df['TIME'])

for i in range(1, 7):
    df[f'PB{i}'] = (df[f'B{i}'] * df['I'])/1000

df['PVT'] = (df['VT'] * df['I'])/1000

def correct_time_resets(df, time_column='TIME'):
    # Convertir la columna de tiempo a datetime si no lo está ya
    df['timestamp'] = pd.to_datetime(df[time_column])

    # Calcular diferencias entre timestamps consecutivos
    time_diff = df['timestamp'].diff()

    # Detectar reinicios (cuando la diferencia es negativa)
    resets = time_diff < timedelta(0)

    # Calcular el offset acumulativo para cada segmento
    cumulative_offset = pd.Timedelta(0)
    corrected_times = df['timestamp'].copy()

    for i in range(1, len(df)):
        if resets[i]:
            # Cuando hay un reinicio, calcular cuánto tiempo debería haber pasado
            # basado en el intervalo típico entre registros
            typical_interval = time_diff[~resets].median()
            cumulative_offset += abs(time_diff[i]) + typical_interval

        corrected_times[i] = df['timestamp'][i] + cumulative_offset

    # Crear nueva columna con los tiempos corregidos
    df['corrected_time'] = corrected_times

    return df

df = correct_time_resets(df)

df['corrected_time'] = pd.to_datetime(df['corrected_time'])
offset = pd.Timestamp('2024-01-01 16:00:00') - df['corrected_time'].min()
df['corrected_time2'] = df['corrected_time'] + offset

plt.figure(figsize=(12, 5))
for i in range(1, 7):
    plt.plot(df['corrected_time2'], df[f'B{i}'], label=f'Battery {i}')
plt.ylabel('Voltage [V]', fontsize=18, labelpad=20)
plt.xlabel('Time [DD-HH-MM]', fontsize=18)

ax = plt.gca()
ax.xaxis.set_major_locator(HourLocator(interval=3))

plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%d-%H-%M'))
plt.xticks(rotation=45)
plt.tight_layout()
plt.tick_params(axis='both', which='major', labelsize=14)

plt.legend(fontsize=14, loc='lower center', bbox_to_anchor=(0.5, -0.45), ncol=6)

plt.grid(True)

plt.savefig('Balance', format='eps', bbox_inches='tight')
plt.show()

direccion = "/content/3dias"

nameColumn = ["B1", "B2", "B3", "B4", "B5", "B6", "I","T","VT","TIME"]
df = pd.read_csv(direccion+".txt",delimiter=',',names=nameColumn)

df['TIME'] = pd.to_datetime(df['TIME'])

for i in range(1, 7):
    df[f'PB{i}'] = (df[f'B{i}'] * df['I'])/1000

df['PVT'] = (df['VT'] * df['I'])/1000

df = correct_time_resets(df)

df['corrected_time'] = pd.to_datetime(df['corrected_time'])
offset = pd.Timestamp('2024-01-01 15:00:00') - df['corrected_time'].min()
df['corrected_time2'] = df['corrected_time'] + offset

plt.figure(figsize=(12, 5))
for i in range(1, 7):
    plt.plot(df['corrected_time2'], df[f'B{i}'], label=f'Battery {i}')
plt.ylabel('Voltage [V]', fontsize=18, labelpad=20)
plt.xlabel('Time [DD-HH-MM]', fontsize=18)

ax = plt.gca()
ax.xaxis.set_major_locator(HourLocator(interval=6))

plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%d-%H-%M'))
plt.xticks(rotation=45)
plt.tight_layout()
plt.tick_params(axis='both', which='major', labelsize=14)

plt.legend(fontsize=14, loc='lower center', bbox_to_anchor=(0.5, -0.45), ncol=6)

plt.grid(True)

plt.savefig('3dias', format='eps', bbox_inches='tight')
plt.show()

plt.figure(figsize=(12, 5))
data_baterias = df[['B1', 'B2', 'B3', 'B4', 'B5', 'B6']]
sns.boxplot(data=data_baterias)
plt.ylabel('Voltage [V]', fontsize=18, labelpad=20)
plt.xlabel('Battery [n]', fontsize=18)



plt.grid(True)

plt.savefig('Cajas', format='eps', bbox_inches='tight')
plt.show()