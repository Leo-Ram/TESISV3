# -*- coding: utf-8 -*-
"""BMSdata1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19FQqGd84HLQ1u2IN3vJDz3R3tsHKJJdT
"""

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from pandas import json_normalize
import seaborn as sns

"""Leer archivos"""

direccion = "/content/datos3d"

nameColumn = ["B1", "B2", "B3", "B4", "B5", "B6", "I","T","VT","TIME"]
df = pd.read_csv(direccion+".txt",delimiter=',',names=nameColumn)

"""procesos"""

df['TIME'] = pd.to_datetime(df['TIME'])

for i in range(1, 7):
    df[f'PB{i}'] = (df[f'B{i}'] * df['I'])/1000

df['PVT'] = (df['VT'] * df['I'])/1000

#print(df.head())

import pandas as pd
from datetime import datetime, timedelta

def correct_time_resets(df, time_column='TIME'):
    """
    Corrige los reinicios en una columna de tiempo, creando una secuencia continua
    que respeta los intervalos originales entre registros.

    Args:
        df: DataFrame con los datos
        time_column: Nombre de la columna que contiene los timestamps

    Returns:
        DataFrame con la columna de tiempo corregida
    """
    # Convertir la columna de tiempo a datetime si no lo está ya
    df['timestamp'] = pd.to_datetime(df[time_column])

    # Calcular diferencias entre timestamps consecutivos
    time_diff = df['timestamp'].diff()

    # Detectar reinicios (cuando la diferencia es negativa)
    resets = time_diff < timedelta(0)

    # Calcular el offset acumulativo para cada segmento
    cumulative_offset = pd.Timedelta(0)
    corrected_times = df['timestamp'].copy()

    for i in range(1, len(df)):
        if resets[i]:
            # Cuando hay un reinicio, calcular cuánto tiempo debería haber pasado
            # basado en el intervalo típico entre registros
            typical_interval = time_diff[~resets].median()
            cumulative_offset += abs(time_diff[i]) + typical_interval

        corrected_times[i] = df['timestamp'][i] + cumulative_offset

    # Crear nueva columna con los tiempos corregidos
    df['corrected_time'] = corrected_times

    return df

# Ejemplo de uso:

# Asumiendo que tus datos están en un DataFrame llamado 'df':
df = correct_time_resets(df)
print(df[['TIME', 'corrected_time']])  # Comparar columnas original y corregida

plt.figure(figsize=(12, 6))
plt.plot(df['corrected_time'], df['I'])
plt.show()

"""g"""

output_filename = direccion+"p"+".csv"
df.to_csv(output_filename, index=False)

"""Graficas"""

# Configuración del estilo
plt.style.use('seaborn')
sns.set_palette("husl")

# 1. Gráfica de voltajes de las 6 baterías a lo largo del tiempo
plt.figure(figsize=(12, 6))
for i in range(1, 7):
    plt.plot(df['corrected_time'], df[f'B{i}'], label=f'Batería {i}')
plt.title('Voltaje de las 6 Baterías vs Tiempo')
plt.xlabel('Tiempo')
plt.ylabel('Voltaje (V)')
plt.legend()
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# 2. Gráfica de corriente y voltaje total
fig, ax1 = plt.subplots(figsize=(12, 6))

# Voltaje total en el eje primario
color = 'tab:blue'
ax1.set_xlabel('Tiempo')
ax1.set_ylabel('Voltaje Total (V)', color=color)
ax1.plot(df['corrected_time'], df['VT'], color=color)
ax1.tick_params(axis='y', labelcolor=color)

# Corriente en el eje secundario
ax2 = ax1.twinx()
color = 'tab:red'
ax2.set_ylabel('Corriente (A)', color=color)
ax2.plot(df['corrected_time'], df['I'], color=color)
ax2.tick_params(axis='y', labelcolor=color)

plt.title('Voltaje Total y Corriente vs Tiempo')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# 3. Boxplot de voltajes de las baterías
plt.figure(figsize=(10, 6))
data_baterias = df[['B1', 'B2', 'B3', 'B4', 'B5', 'B6']]
sns.boxplot(data=data_baterias)
plt.title('Distribución de Voltajes por Batería')
plt.ylabel('Voltaje (V)')
plt.xlabel('Número de Batería')
plt.show()

# 4. Gráfica de potencia total
plt.figure(figsize=(12, 6))
plt.plot(df['corrected_time'], df['PVT'], color='purple')
plt.title('Potencia Total vs Tiempo')
plt.xlabel('Tiempo')
plt.ylabel('Potencia (W)')
plt.grid(True)
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()